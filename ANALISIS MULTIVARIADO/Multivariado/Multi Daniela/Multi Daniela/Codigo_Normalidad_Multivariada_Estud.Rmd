---
title: "Sobre Normalidad Multivariada"
subtitle: "Evaluación, Generación, Gráficos, etc."
author: "Para: Estudiantes de IAM"
date: "`r Sys.Date()`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
\renewcommand\tablename{Tabla}

```{r setup, include = FALSE}
library(knitr)
opts_chunk$set(collapse = TRUE,message=FALSE, warning=FALSE)
```

```{r echo=FALSE}
#library(ggplot2) 
#library(ppcc)
#library(car)
#library(ICS)
#library(RVAideMemoire)
#library(clusterGeneration)
#library(MVN)
#library(kableExtra)
#library(ggplot2) 
library(gdtools)
```

## Prueba de Normalidad Univariada del Coeficiente de Correlación, Ejemplo de notas de Clase

Prueba de Normalidad Univariada mediante la Prueba del Coeficiente de Correlación.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
ejemplo<-c(-1,-0.10,0.16,0.41,0.62,0.80,1.26,1.54,1.71,2.30)
```

En la tabla \ref{ejemplo1-notas}, están los datos de un ejemplo visto en clase.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(kableExtra)
matrix(ejemplo, nrow=1, ncol = 10, byrow=TRUE) %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{ejemplo1-notas}Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

library(ggplot2) 
ejemplo1<-data.frame(ejemplo)

p<-ggplot(ejemplo1, aes(sample = ejemplo1[,1]) ) 
p + geom_qq() + geom_qq_line()+
#ggtitle("Normal Probaility Plot o QQ-plot") + 
         labs(title="Normal Probaility Plot o QQ-plot",
           x = "Valores Teóricos (Estadísticos de Orden)", 
              y = "Valores Muestrales (Quantiles)")+
  theme_bw() +
    theme(axis.text.x = element_text(colour = "grey20", size = 10, angle = 0,
                                     hjust = 0.5, vjust = 0.5),
          axis.text.y = element_text(colour = "grey20", size = 10),
          text = element_text(size = 12))+
  theme(
    panel.background = element_rect(fill = "lightblue"),
    panel.grid.minor = element_line(linetype = "dotted")
  )
#ggsave("figuras/npp.png")
#qqnorm(ejemplo); qqline(ejemplo)
```

\pagebreak

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(ppcc)
cat("\n Resultados de la prueba de normalidad univariada vía la PH del coeficiente de Correlación:\n")

ppccTest(ejemplo, "qnorm")
#ppccTest(ejemplo)
```

## Ejemplo de Notas de Clases (Manual)

Prueba del coeficiente de correlación realizada de manera manual.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
n<-length(ejemplo)
pj<-round((1:n-0.5)/n,4)
qj<-round(qnorm(pj),4)
cor<-cor(qj,sort(ejemplo))
```

El Coeficiente de Correlación es $r$=:`r cor`
\newline

El Valor tabulado en la tabla es: $T_{tabla}=R(n,\alpha)=R(10,0.05)=0.9351$ luego, Como $r>T$-tabulado, luego no se rechaza $H_0:$ Los datos son Normales Univariados

## TRANSFORMACIONES DE POTENCIA INDIVIDUALES (Box-Cox)

Ahora se realizan transformaciones de Box-Cox para acercar los datos a la normalidad univariada.

Primero se tiene la prueba de Shapiro Wilk para Normalidad Univariada para los datos crudos.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos<-read.table("datos/T4-1.dat",dec =".") 
datos2<-cbind(datos[1:10,],datos[11:20,],datos[21:30,],datos[31:40,],datos[41:42,])
```

En la tabla \ref{ejemplo2-notas}, están los datos de un segundo ejemplo visto en clase.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos2 %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{ejemplo2-notas}Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)

library(car)
x<-data.frame(datos)
#dev.new(width=10, height=10)
p<-ggplot(x, aes(sample = x[,1]) ) 
p + geom_qq() + geom_qq_line()+
#qqnorm(x[,1]); qqline(x[,1])
         labs(title="Normal Probaility Plot o QQ-plot",
           x = "Valores Teóricos (Estadísticos de Orden)", 
              y = "Valores Muestrales (Quantiles)")+
  theme_bw() +
    theme(axis.text.x = element_text(colour = "grey20", size = 10, angle = 0,
                                     hjust = 0.5, vjust = 0.5),
          axis.text.y = element_text(colour = "grey20", size = 10),
          text = element_text(size = 12))+
  theme(
    panel.background = element_rect(fill = "lightblue"),
    panel.grid.minor = element_line(linetype = "dotted")
  )

shapiro.test(x[,1])
```

\pagebreak

Ahora se tiene la prueba de Shapiro Wilk para Normalidad Univariada para los datos transformados.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
## para datos transformados
landa=powerTransform(x[,1])
landaf<-landa$lambda
xt<-data.frame((x[,1]^landaf-1)/landaf)
p<-ggplot(xt, aes(sample = xt[,1]) ) 
p + geom_qq() + geom_qq_line() + 
         labs(title="Normal Probaility Plot o QQ-plot",
           x = "Valores Teóricos (Estadísticos de Orden)", 
              y = "Valores Muestrales (Quantiles)")+
  theme_bw() +
    theme(axis.text.x = element_text(colour = "grey20", size = 10, angle = 0,
                                     hjust = 0.5, vjust = 0.5),
          axis.text.y = element_text(colour = "grey20", size = 10),
          text = element_text(size = 12))+
  theme(
    panel.background = element_rect(fill = "lightblue"),
    panel.grid.minor = element_line(linetype = "dotted")
  )

shapiro.test(xt[,1])
```

## Cálclulo del coeficiente de asimetría de Fisher y el coeficiente de Kurtosis para un  conjunto de datos-univariado

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
n<-100
z=rnorm(n)
media=mean(z)
mediana<-median(z)
s2=var(z)*(n-1)/n
s=sqrt(s2)

datos<-cbind(z[1:20],z[21:40],z[41:60],z[61:80],z[81:100])
library(kableExtra)
datos %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{datos-uni-generados}Datos Normales  Univariados Generados",row.names = TRUE) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,
  full_width = FALSE)

# obtención del coeficiente de asimetría muestral
asimetria=function(x) {
m3=mean((x-mean(x))^3)
skew=m3/(sd(x)^3)
skew}
a_normal<-asimetria(z)

cat("\n El coeficiente de Asimetría para el conjunto de datos Univariado Generados es:\n")
a_normal

# obtención del coeficiente de curtosis muestral
kurtosis=function(x) {
m4=mean((x-mean(x))^4)
kurt=m4/(sd(x)^4)
kurt}
k_normal<-kurtosis(z)

cat("\n El coeficiente de Kurtosis para el conjunto de datos Univariado Generados es:\n")
k_normal
```

## Test Para Normalidad Univariada basado en el Coeficiente de Asimetría.

Ahora se tiene una PH de Normalidad Univariada basada en el Coeficiente de asimetría, cuyo estadístico de prueba es:
$$
Z=\sqrt{n/6}*A \sim N(0,1), \ \ \text{donde:} \ \ A-\text{Coeficiente de Asimetría}.
$$

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
estadistico_normal=sqrt(n/6)*a_normal ## Este estadístico se distribuye N(0,1)
cat("\n El estadístico de prueba es: \n")
round(estadistico_normal,4)

pvalor_normal = 2*( 1 - pnorm( abs(estadistico_normal) ) )
cat("\n El Valor-p de la prueba de Asimetria Normal Univariada es: \n")
round(pvalor_normal,4)       ## Valor-p de la prueba de asimetria normal 
```

## Test Para Normalidad Univariada basado en el Coeficiente de Kurtosis.

Ahora se tiene una PH de Normalidad Univariada basada en el Coeficiente de Kurtosis, cuyo estadístico de prueba es:
$$
Z=\sqrt{n/24}*(K-3) \sim N(0,1), \ \ \text{donde:} \ \ K-\text{Coeficiente de Kurtosis}.
$$

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
estad_normal=sqrt(n/24)*(k_normal-3) ## Este estadístico se distribuye N(0,1)
cat("\n El estadístico de prueba es: \n")
round(estad_normal,4)

pvalor_normal = 2*( 1 - pnorm( abs(estad_normal) ) )
cat("\n El Valor-p de la prueba de Kurtosis Normal Univariada es: \n")
round(pvalor_normal,4)       ## Valor-p de la prueba de asimetria normal 
```



\pagebreak

## Pruebas de Normalidad Multivariada

Se utiliza la función _mvn_ del paquete **MVN** para realizar pruebas de Normalidad Multivariada y Univariada con distintas opciones de visualización.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(MVN)
datos<-read.table("datos/T1-5.dat",dec =".")
```

En la tabla \ref{datos}, se encuentra el ancabezado del conjunto de datos seleccionado.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(kableExtra)
datos %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{datos}Encabezado de Datos",row.names = TRUE) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,
  full_width = FALSE)
```

En la tabla \ref{salidas-ph-NM}, se tienen las salidas básicas de la función _mvn_. La prueba multivariada usada es la de Mardia. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
mvn(datos[,c(2,5)],mvnTest=c("mardia"),univariateTest=c("SW")) %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{salidas-ph-NM}Salidas Básicas de PH-NM") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

En la tabla \ref{ph-nm}, se tienen las salidas de la función _mvn_ para la prueba normal  multivariada usada, en este caso la prueba de Mardia. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1<-mvn(datos[,c(2,5)],mvnTest=c("mardia"),univariateTest=c("SW"))
result1$multivariateNormality %>%
kable(booktabs = TRUE,format = "latex",caption="\\label{ph-nm}Prueba de Normalidad Multivariada",align = c('c', 'r', 'r', 'c'), col.names = c("Prueba","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,NA,NA,NA),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

En la tabla \ref{ph-nu}, se tienen las salidas de la función _mvn_ para las pruebas normal  univariada usada, en este caso la prueba de Shapiro-Wilk. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$univariateNormality %>% 
kable(booktabs = TRUE,format = "latex",caption="\\label{ph-nu}Prueba de Normalidad Univariada", align = c('c', 'c', 'c', 'c', 'c'),col.names = c("Prueba","Variables","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,NA,3,3,NA),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

En la tabla \ref{descriptivos0}, se tiene un resumen descriptivo de las variables del conjunto de datos p-variado usado, en este caso el conjunto de datos consta de dos variables.  Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$Descriptive %>% 
kable(booktabs = TRUE,format = "latex",caption="\\label{descriptivos0}Resumen Descriptivo", align = c("c", "c", "r", "r", "r", "r", "r", "r", "r", "r", "r"),  col.names = c("n", "Media", "DesvEst", "Mediana", "Min", "Máx", "Per.25", "Per.75", "Asimetría", "Kurtosis"),   digits=c(0,3,3,3,3,3,3,3,3,3,3),  format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```


## Coeficientes de Asimetría y Kurtosis Multivariado-Distancia de Mahalanobis

Los coeficientes de Asimetría y Kurtosis **UNIVARIADOS** son respectivamente: `r asimetria(datos[,2])` y `r kurtosis(datos[,2])-3` para la variable $V_2$ y `r asimetria(datos[,5])` y `r kurtosis(datos[,5])-3` para la variable $V_5$. 

En la tabla \ref{mahalanobis}, se tienen las distnacias de Mahalanobis (al cuadrado) de cada Observación al vector de medias de los datos. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
x<-as.matrix(datos[,c(2,5)])
n<-nrow(x)
media<-apply(x,2,mean)
var<-var(x)
s=var*(n-1)/n
# Uso de la función: mahalanobis
distancias2<-mahalanobis(x,media,s)
distancias2<-cbind(distancias2[1:10],distancias2[11:20],distancias2[21:30],distancias2[31:40],distancias2[41:42])
round(distancias2,4) %>% 
kable(booktabs = TRUE,format = "latex",caption="\\label{mahalanobis}Distancias de Mahalanobis a la media") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8, full_width = FALSE)
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
#--- Diagonalización de s
auto=eigen(s)
v=auto$vectors
lambda=auto$values
si12=v%*%diag(1/sqrt(lambda))%*%t(v)
#--- Estandarización multivariada
xs=(x-rep(1,n)%*%t(media))%*%si12
#--- Similaridades
r=xs%*%t(xs)
asimetria_multv<-(1/n^2)*sum(r^3)
```
luego, en este caso el Coeficiente de Asimetría Multivariado es $A_m$=`r asimetria_multv`. 

**El Coeficiente de Asimetría Multivariado esta dado por:** 
$$
A_m=\frac{1}{n^2}\sum_{i=1}^n\sum_{j=1}^n r_{ij}^3
$$
$$
\text{donde:}\ \ \ \ r_{ij}=(\underline{X}_i-\overline{X})^T\mathbf{S}^{-1}(\underline{X}_j-\overline{X}).
$$
Para $i=j$ se tienen las distancias de Mahalanobis de cada observación al vector de medias,  es decir,
$$
d_M^2\ \biggl(\ \underline{X}_i\ , \ \overline{X}\ \biggr)=r_{ii}=(\underline{X}_i-\overline{X})^T\mathbf{S}^{-1}(\underline{X}_i-\overline{X}).
$$
luego, en este caso el Coeficiente de Asimetría Multivariado es $A_m$=`r asimetria_multv`. 

**El Coeficiente de Kurtosis Multivariado esta dado por:** 
$$
K_m=\frac{1}{n}\sum_{i=1}^n r_{ii}^2=\frac{1}{n}\sum_{i=1}^n d_M^4\ \bigl(\ \underline{X}_i\ , \ \overline{X}\ \bigr)
$$ 
```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
kurtosis_multv<-(1/n)*sum(distancias2[1:42]^2)

km=(1/n)*sum(diag(r)^2)
```
luego, en este caso el Coeficiente de Kurtosis Multivariado es $K_m$=`r kurtosis_multv`=`r  km` 


\pagebreak

En la tabla \ref{ph-nm-royston}, están las Salidas básicas de la función _mvn_ usando la  prueba multivariada de Royston. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
mvn(datos[,c(2,5)],mvnTest=c("royston"),univariateTest=c("SW")) %>% 
kable(booktabs = TRUE,format = "latex",caption="\\label{ph-nm-royston}Salidas Básicas PH NM- Royston") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result2<-mvn(datos[,c(2,5)],mvnTest=c("royston"),univariateTest=c("SW"))
result2$multivariateNormality %>% 
kable(booktabs = TRUE,format = "latex",caption="Prueba de Normalidad Multivariada",align = c('c', 'r', 'r', 'c'), col.names = c("Prueba","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(0,5,5,0),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result2$univariateNormality %>%
kable(booktabs = TRUE,format = "latex",caption="Prueba de Normalidad Univariada", align = c('c', 'c', 'c', 'c', 'c'),
      col.names = c("Prueba","Variables","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(0,0,3,3,0),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result2$Descriptive %>%
kable(booktabs = TRUE,format = "latex",caption="Resumen Descriptivo", align = c("c", "c", "r", "r", "r", "r", "r", "r", "r", "r", "r"),  col.names = c("n", "Media", "DesvEst", "Mediana", "Min", "Máx", "Per.25", "Per.75", "Asimetría", "Kurtosis"),   digits=c(0,3,3,3,3,3,3,3,3,3,3),  format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```


\pagebreak

Salidas básicas de la función _mvn_. La prueba multivariada usada es la de Mardia. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

En la tabla \ref{datos}, se encuentra el ancabezado del conjunto de datos seleccionado.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
head(datos,10) %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{datos}Encabezado de Datos",row.names = TRUE) %>%
  kable_styling(latex_options = c("striped", "condensed","hold_position"),
  position = "center", font_size=8,
  full_width = FALSE)
```

En la tabla \ref{nor-multiv}, se encuentran los resultados de la prueba de normalidad multivariada realizada según la prueba seleccionada de las disponibles en el argumento _mvnTest_ de la función _mvn_.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1<-mvn(datos[,c(2,5)],mvnTest=c("mardia"),univariateTest=c("SW"))
result1$multivariateNormality %>%
kable(booktabs = TRUE,format = "latex",caption="\\label{nor-multiv}Prueba de Normalidad Multivariada",align = c('c', 'r', 'r', 'c'),col.names = c("Prueba","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,5,5,NA)) %>% 
kable_styling(latex_options = c("striped", "condensed","hold_position"),
  position = "center", font_size=8,full_width = FALSE)
```

En la tabla \ref{nor-univ}, se encuentran los resultados de las pruebas de normalidad univariadas para cada una de las variables del conjunto de datos p-variados.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$univariateNormality %>%
kable(booktabs = TRUE,format = "latex", caption="\\label{nor-univ}Prueba de Normalidad Univariada", align = c('c', 'c', 'c', 'c', 'c'), col.names = c("Prueba","Variables","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,NA,3,3,0),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","hold_position"),
  position = "center", full_width = FALSE)
```

En la tabla \ref{descriptivos2} aparece un resumen descriptivo de las variables del conjunto de datos p-variado. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$Descriptive %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{descriptivos2}Resumen Descriptivo", align = c("c", "c", "r", "r", "r", "r", "r", "r", "r", "r", "r"),  col.names = c("n", "Media", "DesvEst", "Mediana", "Min", "Máx", "Per.25", "Per.75", "Asimetría", "Kurtosis"),   digits=c(0,3,3,3,3,3,3,3,3,3,3),  format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","scale_down","hold_position"),
  position = "center", full_width = FALSE)
```

\pagebreak

Salidas básicas de la función _mvn_. La prueba multivariada usada es la de Mardia. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

En la tabla \ref{datos-gen}, se encuentra el ancabezado del conjunto de datos Normal Multivariado generados a partir del R.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(clusterGeneration)
sigma<-genPositiveDefMat("eigen",dim=5)$Sigma  
mu=c(0,0,0,0,0)
datos_gen<-as.data.frame(mvrnorm(n=100, mu,sigma))
datos_gen %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{datos-gen}Conjunto de Datos NM Generados", row.names = TRUE,longtable=TRUE,digits=5, col.names=c("X1","X2","X3","X4","X5")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position","repeat_header"),
  position = "center", font_size=8, full_width = FALSE,
  repeat_header_text = "continuación",
  repeat_header_continued="continúa en la siguiente página")
```

En la tabla \ref{nor-multiv}, se encuentran los resultados de la prueba de normalidad multivariada realizada según la prueba seleccionada de las disponibles en el argumento _mvnTest_ de la función _mvn_.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1<-mvn(datos_gen,mvnTest=c("mardia"),univariateTest=c("SW"))
result1$multivariateNormality %>%
kable(booktabs = TRUE,format = "latex",caption="\\label{nor-multiv}Prueba de Normalidad Multivariada",align = c('c', 'r', 'r', 'c'),col.names = c("Prueba","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,5,5,NA)) %>% 
kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

En la tabla \ref{nor-univ}, se encuentran los resultados de las pruebas de normalidad univariadas para cada una de las variables del conjunto de datos p-variados.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$univariateNormality %>%
kable(booktabs = TRUE,format = "latex", caption="\\label{nor-univ}Prueba de Normalidad Univariada", align = c('c', 'c', 'c', 'c', 'c'), col.names = c("Prueba","Variables","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,NA,3,3,0),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", full_width = FALSE)
```

En la tabla \ref{descriptivos2} aparece un resumen descriptivo de las variables del conjunto de datos p-variado. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$Descriptive %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{descriptivos2}Resumen Descriptivo", align = c("c", "c", "r", "r", "r", "r", "r", "r", "r", "r", "r"),  col.names = c("n", "Media", "DesvEst", "Mediana", "Min", "Máx", "Per.25", "Per.75", "Asimetría", "Kurtosis"),   digits=c(0,3,3,3,3,3,3,3,3,3,3),  format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","scale_down","HOLD_position"),
  position = "center", full_width = FALSE)
```

\pagebreak

Resultados con Gráfico QQ-Plot para la PH de Normalidad Multivariada utilizando la función **mvn**.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul2<-mvn(datos_gen,mvnTest=c("mardia"),univariateTest=c("SW"),multivariatePlot="qq")
```

\pagebreak

Prueba de Shapiro_Multivariada para normalidad con la función _mshapiro.test_ del paquete: **RVAideMemoire**.

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
library(RVAideMemoire)
mshapiro.test(datos_gen)
```

## Prueba de Norm. multivariada basada en Asimetría 

A continuación se tienen los resultados de la PH para NM basada en Asimetría, utilizando la función _mvnorm.skew.test_ del paquete **ICS**. Favor exlorar este paquete y sus funciones disponibles.

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
library(ICS)
mvnorm.skew.test(datos_gen)

mvnorm.skew.test(datos[,c(2,5,6)])
```


Gráfico qq-plot para Normalidad Multivariada con la función **mqqnorm**.

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
mqqnorm(datos_gen,main="Gráfico QQ-Plot para Normalidad Multivariada")
```

\pagebreak

Resultados con Gráfico Box-Plot para la PH de Normalidad Multivariada utilizando la función **mvn**.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul3<-mvn(datos_gen,mvnTest=c("mardia"),univariateTest=c("SW"),univariatePlot="box",desc=FALSE)
resul3 %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{salidas-sin-desc}Salidas sin Resumen Descriptivo",format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", full_width = FALSE)
```

\pagebreak

En la tabla \ref{salidas-con-box-cox}, se tienen los resultados de PH con la función _mvn_ junto con Observaciones atípicas y transformaciones de Box-Cox.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul4<-mvn(datos[,c(2,5,6)],mvnTest=c("mardia"),univariateTest=c("SW"),
            multivariateOutlierMethod="quan",bc=TRUE,bcType="optimal",
            showOutliers=TRUE,desc=TRUE)
resul4 %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{salidas-con-box-cox}Salidas Obs. Atípicas y Tranf. de Box-Cox",format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

En la tabla \ref{nor-multiv2}, se encuentran los resultados de la prueba de normalidad multivariada realizada según la prueba seleccionada de las disponibles en el argumento _mvnTest_ de la función _mvn_.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul4$multivariateNormality %>%
kable(booktabs = TRUE,format = "latex",caption="\\label{nor-multiv2}Prueba de Normalidad Multivariada",align = c('c', 'r', 'r', 'c'),col.names = c("Prueba","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,5,5,NA)) %>% 
kable_styling(latex_options = c("striped", "condensed","hold_position"),
  position = "center", font_size=8,full_width = FALSE)
```

En la tabla \ref{nor-univ2}, se encuentran los resultados de las pruebas de normalidad univariadas para cada una de las variables del conjunto de datos p-variados.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul4$univariateNormality %>%
kable(booktabs = TRUE,format = "latex", caption="\\label{nor-univ2}Prueba de Normalidad Univariada", align = c('c', 'c', 'c', 'c', 'c'), col.names = c("Prueba","Variables","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,NA,3,3,0),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","hold_position"),
  position = "center", full_width = FALSE)
```

En la tabla \ref{descriptivos3} aparece un resumen descriptivo de las variables del conjunto de datos p-variado. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul4$Descriptive %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{descriptivos3}Resumen Descriptivo", align = c("c", "c", "r", "r", "r", "r", "r", "r", "r", "r", "r"),  col.names = c("n", "Media", "DesvEst", "Mediana", "Min", "Máx", "Per.25", "Per.75", "Asimetría", "Kurtosis"),   digits=c(0,3,3,3,3,3,3,3,3,3,3),  format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","hold_position"),
  position = "center", full_width = FALSE)
```

\pagebreak

En la tabla \ref{obs-atipicas}, se muestran las observaciones atípicas en los datos.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul5<-mvn(datos[,c(2,5,6)],mvnTest=c("mardia"),univariateTest=c("SW"),
multivariateOutlierMethod="quan",bc=TRUE,bcType="optimal",showOutliers=TRUE,showNewData=TRUE)

resul5$multivariateOutliers %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{obs-atipicas}Observaciones Atípicas",format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

\pagebreak

En la tabla \ref{box-cox}, se muestran los valores de Lambda para las transformaciones de Box-Cox.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul5<-mvn(datos[,c(2,5,6)],mvnTest=c("mardia"),univariateTest=c("SW"),
multivariateOutlierMethod="quan",bc=TRUE,bcType="optimal",showOutliers=TRUE,showNewData=TRUE)

resul5$BoxCoxPowerTransformation %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{box-cox}Valores de lambda para Box-Cox",format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

\pagebreak

En la tabla \ref{datos-transf}, se muestran los nuevos datos transfromados con Box-Cox.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul5<-mvn(datos[,c(2,5,6)],mvnTest=c("mardia"),univariateTest=c("SW"),
multivariateOutlierMethod="quan",bc=TRUE,bcType="optimal",showOutliers=TRUE,showNewData=TRUE)

resul5$newData %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{datos-transf}Datos transformados con Box-Cox",row.names=TRUE,format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

\pagebreak

## Función R que representa datos bivariados, junto con elipses de confianza

Con esta función se realzia un gráfico de dispersión de dos variables junto con dos elipses de confianza del $(1-\alpha_1)100\%$ y $(1-\alpha_2)100\%$. El centro de la elipse está representado por un punto de color azul.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
representa2=function(x,alfa1,alfa2,texto){ # Los datos se encuentran en la matriz x
p=ncol(x)     ##  Número de variables=2
n=nrow(x)     ##  Número de individuos
#####--- Cálculo del vector de medias y matriz de covarianzas
med=apply(x,2,mean)
sc=cov(x)           ## S
s=sc*(n-1)/n        ## Sn
#####--- Diagonalización de s
auto=eigen(s)

v=auto$vectors      ## Vectores propios
lambda=auto$values  ## Valores  propios

#####--- Gráfico de Dispersión
library(latex2exp)
plot(x[,1],x[,2],xlab=texto,ylab="",pch=20, xlim=c(min(x[,1])-1,max(x[,1])+1), ylim=c(min(x[,2])-1,max(x[,2])+1), 
     main = TeX('Con\ \ $\\underline{\\mu}$\ y $\\mathbf{\\Sigma}$ \ \ dados, \ \ $(1-\\alpha_1)$, $(1-\\alpha_2)100\\%$ '))
points(med[1],med[2],pch=19,col="blue")  ## El centroide, (x-barra,y-barra)
abline(h=med[2],lty=2)
abline(v=med[1],lty=2)

####### Gráfico de la Elipse
teta=seq(0,2*pi,length=101)   ## Vector con los ángulos
#####--- Truco para repetir el vector de medias k veces, en 101 filas
medr=matrix(rep(med,101),byrow=TRUE,nrow=101)

c1<-qchisq(alfa1,2)
c2<-qchisq(alfa2,2)

elipse01=medr+sqrt(c1)*t(sqrt(lambda[1])*v[,1]%*%t(cos(teta))+sqrt(lambda[2])*v[,2]%*%t(sin(teta)))  ## contorno eliptico del alfa1%

elipse02=medr+sqrt(c2)*t(sqrt(lambda[1])*v[,1]%*%t(cos(teta))+sqrt(lambda[2])*v[,2]%*%t(sin(teta)))  ## contorno eliptico del alfa2%
lines(elipse01,col="blue")
lines(elipse02,col="red")
}
```


```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(MASS)
library(mvtnorm)
library(MVN)

par(mfrow=c(2,2))
mu=c(2,2)

mu=c(2,2)
sigma<-matrix(c(5,4,4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.9,0.95,"(a) Normal Bivariada")   

mu=c(0,0)
sigma<-matrix(c(3,0,0,3),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.5,0.95,"(a) Normal Bivariada")   

mu=c(2,0)
sigma<-matrix(c(5,-4,-4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.5,0.95,"(a) Normal Bivariada")   

mu=c(0,2)
sigma<-matrix(c(5,-4,-4,10),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.5,0.95,"(a) Normal Bivariada")  
```

\pagebreak

Se utiliza la función _genPositiveDefMat_ del paquete __clusterGeneration__ para generar Matrices Simétricas Definida-Positiva que se usan como Matrices de Var-Cov $\pmb{\Sigma}$  de los datos Normales Multivariados generados posteriormente.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(clusterGeneration)
sigma<-genPositiveDefMat("eigen",dim=2)$Sigma  
mu=c(0,0)
datos2<-round(mvrnorm(n=100, mu,sigma),4)

cat("\n La matriz de Var-Cov Utilizada es:\ \ \n") 

library(kableExtra)
sigma %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matrix Var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa2(datos2,0.5, 0.90, "(a) Normal Bivariada")  
```

Ahora para un conjunto de **datos bi-variados dado**, se utiliza la función anterior para representar los datos gráficamente junto a elipses de confianza específicas. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos<-read.table("datos/T1-5.dat",dec =".")

datos2<-datos[,c(5,6)]

head(datos2,5) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Encabezado de Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)


cat("\n El Vector de medias y La matriz de Var-Cov Utilizadas son:\ \ \n") 

apply(datos2,2,mean) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Vector de Medias") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

var(datos2) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matriz de var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa2(datos2,0.5, 0.90, "(a) Datos Bivariados")  
```

\pagebreak

## Función R que representa datos bivariados, junto con el vector de medias

Con esta función se realzia un gráfico de dispersión de dos variables junto con una elipse de confianza del $(1-\alpha)100\%$. El centro de la elipse está representado por un punto de color azul.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
representa1=function(x,alfa1,texto){
p=ncol(x)     
n=nrow(x)     
med=apply(x,2,mean)
sc=cov(x)           
s=sc*(n-1)/n        
auto=eigen(s)
v=auto$vectors      
lambda=auto$values  
library(latex2exp)
plot(x[,1],x[,2],xlab=texto,ylab="",pch=20, xlim=c(min(x[,1])-1,max(x[,1])+1), ylim=c(min(x[,2])-1,max(x[,2])+1), 
     main = TeX('Con\ \ $\\underline{\\mu}$\ y $\\mathbf{\\Sigma}$ \ \ dados, \ \ $(1-\\alpha)100\\%$ '))
points(med[1],med[2],pch=19,col="blue")        
abline(h=med[2],lty=2)
abline(v=med[1],lty=2)
teta=seq(0,2*pi,length=101)                    
medr=matrix(rep(med,101),byrow=TRUE,nrow=101)
c1<-qchisq(alfa1,2)
elipse01=medr+sqrt(c1)*t(sqrt(lambda[1])*v[,1]%*%t(cos(teta))+sqrt(lambda[2])*v[,2]%*%t(sin(teta))) 
#lines(elipse01,col="blue",type="n")
lines(elipse01,col="blue",type="l")
}
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
par(mfrow=c(2,2))
mu=c(2,2)

mu=c(2,2)
sigma<-matrix(c(5,4,4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.95,"(a) Normales")   

mu=c(0,0)
sigma<-matrix(c(3,0,0,3),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.5,"(a) Normales")   

mu=c(2,0)
sigma<-matrix(c(5,-4,-4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.85,"(a) Normales")   

mu=c(0,2)
sigma<-matrix(c(5,-4,-4,10),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.9,"(a) Normales")  
```

\pagebreak

Con esta función se realzia una elipse de confianza del $(1-\alpha)100\%$. El centro de la elipse está representado por un punto de color azul.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
representa1B=function(x,alfa1,texto){
p=ncol(x)     
n=nrow(x)     
med=apply(x,2,mean)
sc=cov(x)           
s=sc*(n-1)/n        
auto=eigen(s)
v=auto$vectors      
lambda=auto$values  
library(latex2exp)
plot(x[,1],x[,2], type="n", xlab=texto,ylab="",pch=20, xlim=c(min(x[,1])-1,max(x[,1])+1), ylim=c(min(x[,2])-1,max(x[,2])+1), 
     main = TeX('Con\ \ $\\underline{\\mu}$\ y $\\mathbf{\\Sigma}$ \ \ dados, \ \ $(1-\\alpha)100\\%$ '))
points(med[1],med[2],pch=19,col="blue")        
abline(h=med[2],lty=2)
abline(v=med[1],lty=2)
teta=seq(0,2*pi,length=101)                    
medr=matrix(rep(med,101),byrow=TRUE,nrow=101)
c1<-qchisq(alfa1,2)
elipse01=medr+sqrt(c1)*t(sqrt(lambda[1])*v[,1]%*%t(cos(teta))+sqrt(lambda[2])*v[,2]%*%t(sin(teta))) 
#lines(elipse01,col="blue",type="n")
lines(elipse01,col="blue",type="l")
}
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
par(mfrow=c(2,2))
mu=c(2,2)

mu=c(2,2)
sigma<-matrix(c(5,4,4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1B(datos2,0.95,"(a) Normales")   

mu=c(0,0)
sigma<-matrix(c(3,0,0,3),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1B(datos2,0.5,"(a) Normales")   

mu=c(2,0)
sigma<-matrix(c(5,-4,-4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1B(datos2,0.85,"(a) Normales")   

mu=c(0,2)
sigma<-matrix(c(5,-4,-4,10),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1B(datos2,0.9,"(a) Normales")  
```

\pagebreak

Se utiliza la función _genPositiveDefMat_ del paquete __clusterGeneration__ para generar Matrices Simétricas Definida-Positiva que se usan como Matrices de Var-Cov $\pmb{\Sigma}$  de los datos Normales Multivariados generados posteriormente.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(clusterGeneration)
sigma<-genPositiveDefMat("eigen",dim=2)$Sigma  
mu=c(0,0)
datos2<-round(mvrnorm(n=100, mu,sigma),4)

cat("\n La matriz de Var-Cov Utilizada es:\ \ \n") 

sigma %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matriz de var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa1(datos2,0.90, "(a) Normal Bivariada")  
```

Con esta función se realzia un gráfico de dispersión de dos variables junto con una elipse de confianza del $(1-\alpha)100\%$. El centro de la elipse está representado por un punto de color azul.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos<-read.table("datos/T1-5.dat",dec =".")

datos2<-datos[,c(5,6)]

head(datos2,5) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Encabezado de Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

cat("\n El Vector de medias y La matriz de Var-Cov Utilizadas son:\ \ \n") 

apply(datos2,2,mean) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Vector de Medias") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

var(datos2) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matriz de var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa1(datos2, 0.90, "(a) Datos Bivariados")  
```

Ahora para un conjunto de **datos bi-variados dado**, se utiliza la función anterior para representar una elipse de confianza específica. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos<-read.table("datos/T1-5.dat",dec =".")

datos2<-datos[,c(5,6)]

head(datos2,5) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Encabezado de Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

cat("\n El Vector de medias y La matriz de Var-Cov Utilizadas son:\ \ \n") 

apply(datos2,2,mean) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Vector de Medias") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

var(datos2) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matriz de var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa1B(datos2, 0.90, "(a) Datos Bivariados")  
```

\pagebreak

##  Grafica de Superficies Normaales Bivariadas                                         

Ahora se grafican las superficies de varias f.d.p. normal multivariada con disptintas perspectivas de vistas.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
media <- c(5, 5)
varianza <- matrix(c(2, 0, 0, 2), ncol=2)
library(clusterGeneration)  ### package clusterGeneration, para generar MSDP ###
#sigma<-genPositiveDefMat("eigen",dim=2)$Sigma      

x <- seq(from=0, to=10, length.out=60)
y <- seq(from=0, to=10, length.out=60)

fun <- function(x, y) dmvnorm(c(x, y), mean=media, sigma=varianza)
fun <- Vectorize(fun)
z <- outer(x, y, fun)

media1 <- c(5, 5)
varianza1 <- matrix(c(1.3, 1, 1, 1.3), ncol=2)

fun1 <- function(x, y) dmvnorm(c(x, y), mean=media1, sigma=varianza1)
fun1 <- Vectorize(fun1)
z1 <- outer(x, y, fun1)

media2 <- c(5, 5)
varianza2 <- matrix(c(1.3, -1, -1, 1.3), ncol=2)

fun2 <- function(x, y) dmvnorm(c(x, y), mean=media2, sigma=varianza2)
fun2 <- Vectorize(fun2)
z2 <- outer(x, y, fun2)

# Gráficas 2x2

par(mfrow=c(2, 2), mar=c(1, 1, 1, 2))
persp(x, y, z, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)
persp(x, y, z1, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)

persp(x, y, z2, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)
persp(x, y, z1, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)
```

\pagebreak

Más ejemplos de superficies de f.d.p normal multivariadas en varias perspectivas de vistas:

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
x<-seq(-4,4,len=50)
y<-seq(-4,4,len=50)

normal.bivariada<-function(x,y,rho,mu1,sigma1,mu2,sigma2){
1/(2*pi*sigma1*sigma2*sqrt(1-rho^2))*exp(-1/(2*(1-rho^2))*
(((x-mu1)/sigma1)^2-2*rho*((x-mu1)/sigma1)*((y-mu2)/sigma2)+
((y-mu2)/sigma2)^2))
}

f<-outer(x,y,normal.bivariada,rho=0.5,mu1=0,sigma1=2^0.5,mu2=2,sigma2=1)

#### Inicio de Gráfico matrix 2x2
nf<-layout(matrix(c(1,2,3,4),ncol=2,byrow=T),widths=c(rep(12,4)),heights=c(rep(12,2)),respect=T)

#library(latex2exp)
par(mar=c(1,1,4,1))
persp(x,y,f,theta = 30, phi = 30, col = "lightblue",xlab = "X", ylab = "Y", zlab = "Z",
  main = TeX('$\\rho=0.5$, \ $\\mu_1=0$, \ $\\mu_2=2$, \ $\\sigma_1=\\sqrt{2}$, \ $\\sigma_2=1$') , cex.main=0.8)

par(mar=c(1,1,4,1)) 
persp(x,y,f,theta = -10, phi = 30, col = "lightblue", xlab = "X", ylab = "Y", zlab ="Z",main="rho=0.5",cex.main=0.8)

par(mar=c(1,1,4,1))
persp(x,y,f,theta = 30, phi = 0, col = "lightblue",xlab = "X", ylab = "Y", zlab ="Z",main="rho=0.5",cex.main=0.8)

par(mar=c(1,1,4,1))
persp(x,y,f,theta = 0, phi = -40, col = "lightblue",xlab = "X", ylab = "Y", zlab ="Z",main="rho=0.5",cex.main=0.8)
```

\pagebreak

##  Grafica de Contornos de Superficies de Normaales Bivariadas   

Ahora se tienen gráficos de contornos de f.f.p normal multivariada.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
x<-seq(0,10,len=60)
y<-seq(0,10,len=60)

media <- c(5, 5)
varianza <- matrix(c(1.3, 1, 1, 1.3), ncol=2)

fun <- function(x, y) dmvnorm(c(x, y), mean=media, sigma=varianza)
fun <- Vectorize(fun)

z<-outer(x,y,fun)

par(mfrow=c(1,2))
persp(x, y, z, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)

contour(x,y,z, nlevels=3,levels=c(0.01,0.05,0.1),labels=c(0.01,0.05,0.1),lwd=1.5,xlab=expression(x[1]),ylab=expression(x[2]),main="Contornos de verosimilitud del 90%,95% y 99%",cex.main=0.85)

par(mfrow=c(1,2))
persp(x, y, z2, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)

contour(x,y,z2, nlevels=3,levels=c(0.01,0.05,0.1),labels=c(0.01,0.05,0.1),lwd=1.5,xlab=expression(x[1]),ylab=expression(x[2]),main="Contornos de verosimilitud del 90%,95% y 99%",cex.main=0.85)
```



