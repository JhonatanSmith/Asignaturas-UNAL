---
author: "Nombre Completo Autor"
date: "27/10/2017"
documentclass: book
forprint: yes
fontsize: 12pt
geometry: margin = 2.5cm
bibliography:
- bib/library.bib
- bib/paquetes.bib
metodobib: yes
biblio-style: plainnat
csl: methods-in-ecology-and-evolution.csl
link-citations: yes
output:
  pdf_document:
    keep_tex: no
    number_sections: yes
    citation_package: natbib
    fig_caption: yes
    template: latex/plantilla_trabajos.tex
    includes: null
  word_document: default
---

```{r include=FALSE}
knitr::opts_chunk$set(fig.path = 'figurasR/',
                      echo = FALSE, warning = FALSE, message = FALSE,
                      fig.pos="H",fig.align="center",out.width="95%",
                      cache=FALSE)
```

```{r setup, include = F, message = F}
if(!require(pacman)){install.packages("pacman"); library(pacman)}
pacman::p_load("tidyverse", "ggplot2", "pBrackets", "knitr", "HH", "car", "rgl", "sampling","biotools")
source("funcionesR/funciones.R", local = knitr::knit_global())
#source("funcionesR/Functions.R", local = knitr::knit_global())
```


<!-- \setcounter{chapter}{2} -->
<!-- \setcounter{chapter}{2} escribir 2 para capítulo 3  -->
<!-- \pagenumbering{arabic} -->

\ifdefined\ifprincipal
\else
\setlength{\parindent}{1em}
\pagestyle{fancy}
\setcounter{tocdepth}{4}
\tableofcontents
<!-- \nocite{*} -->
\fi

\ifdefined\ifdoblecara
\fancyhead{}{}
\fancyhead[LE,RO]{\scriptsize\rightmark}
\fancyfoot[LO,RE]{\scriptsize\slshape \leftmark}
\fancyfoot[C]{}
\fancyfoot[LE,RO]{\footnotesize\thepage}
\else
\fancyhead{}{}
\fancyhead[RO]{\scriptsize\rightmark}
\fancyfoot[LO]{\scriptsize\slshape \leftmark}
\fancyfoot[C]{}
\fancyfoot[RO]{\footnotesize\thepage}
\fi
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}


# Gráficos Bivariados Varios

## Función R que representa datos bivariados, junto con elipses de confianza

Con esta función se realzia un gráfico de dispersión de dos variables junto con dos elipses de confianza del $(1-\alpha_1)100\%$ y $(1-\alpha_2)100\%$. El centro de la elipse está representado por un punto de color azul.

```{r, echo=FALSE}
library(MASS)
library(mvtnorm)
library(MVN)


par(mfrow=c(2,2))
mu=c(2,2)

mu=c(2,2)
sigma<-matrix(c(5,4,4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.9,0.95,"(a) Normales")   

mu=c(0,0)
sigma<-matrix(c(3,0,0,3),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.5,0.95,"(a) Normales")   

mu=c(2,0)
sigma<-matrix(c(5,-4,-4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.5,0.95,"(a) Normales")   

mu=c(0,2)
sigma<-matrix(c(5,-4,-4,10),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.5,0.95,"(a) Normales")  
```

## Función R que representa datos bivariados, junto con el vector de medias

```{r, echo=FALSE}
par(mfrow=c(2,2))
mu=c(2,2)

mu=c(2,2)
sigma<-matrix(c(5,4,4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.95,"(a) Normales")   

mu=c(0,0)
sigma<-matrix(c(3,0,0,3),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.5,"(a) Normales")   

mu=c(2,0)
sigma<-matrix(c(5,-4,-4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.85,"(a) Normales")   

mu=c(0,2)
sigma<-matrix(c(5,-4,-4,10),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.9,"(a) Normales")  
```

##  Grafica de Superficies de Normaales Bivariadas 

```{r, echo=FALSE}
media <- c(5, 5)
varianza <- matrix(c(2, 0, 0, 2), ncol=2)
library(clusterGeneration)  ### package clusterGeneration, para generar MSDP ###
#sigma<-genPositiveDefMat("eigen",dim=2)$Sigma      

x <- seq(from=0, to=10, length.out=60)
y <- seq(from=0, to=10, length.out=60)

fun <- function(x, y) dmvnorm(c(x, y), mean=media, sigma=varianza)
fun <- Vectorize(fun)
z <- outer(x, y, fun)

media1 <- c(5, 5)
varianza1 <- matrix(c(1.3, 1, 1, 1.3), ncol=2)

fun1 <- function(x, y) dmvnorm(c(x, y), mean=media1, sigma=varianza1)
fun1 <- Vectorize(fun1)
z1 <- outer(x, y, fun1)

par(mfrow=c(1, 2), mar=c(1, 1, 1, 2))
persp(x, y, z, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)
persp(x, y, z1, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)

media2 <- c(5, 5)
varianza2 <- matrix(c(1.3, -1, -1, 1.3), ncol=2)

fun2 <- function(x, y) dmvnorm(c(x, y), mean=media2, sigma=varianza2)
fun2 <- Vectorize(fun2)
z2 <- outer(x, y, fun2)

par(mfrow=c(1, 2), mar=c(1, 1, 1, 2))
persp(x, y, z2, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)
persp(x, y, z1, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)
```

### Varios Ejemplos de Perpectivas 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
x<-seq(-4,4,len=50)
y<-seq(-4,4,len=50)

normal.bivariada<-function(x,y,rho,mu1,sigma1,mu2,sigma2){
1/(2*pi*sigma1*sigma2*sqrt(1-rho^2))*exp(-1/(2*(1-rho^2))*
(((x-mu1)/sigma1)^2-2*rho*((x-mu1)/sigma1)*((y-mu2)/sigma2)+
((y-mu2)/sigma2)^2))
}

f<-outer(x,y,normal.bivariada,rho=0.5,mu1=0,sigma1=2^0.5,mu2=2,sigma2=1)

#### Inicio de Gráfico matrix 2x2
nf<-layout(matrix(c(1,2,3,4),ncol=2,byrow=T),widths=c(rep(12,4)),heights=c(rep(12,2)),respect=T)

library(latex2exp)
par(mar=c(1,1,4,1))
persp(x,y,f,theta = 30, phi = 30, col = "lightblue",xlab = "X", ylab = "Y", zlab = "Z",
  main = TeX('$\\rho=0.5$, \ $\\mu_1=0$, \ $\\mu_2=2$, \ $\\sigma_1=\\sqrt{2}$, \ $\\sigma_2=1$') , cex.main=0.8)

par(mar=c(1,1,4,1)) 
persp(x,y,f,theta = -10, phi = 30, col = "lightblue", xlab = "X", ylab = "Y", zlab ="Z",main="rho=0.5",cex.main=0.8)

par(mar=c(1,1,4,1))
persp(x,y,f,theta = 30, phi = 0, col = "lightblue",xlab = "X", ylab = "Y", zlab ="Z",main="rho=0.5",cex.main=0.8)

par(mar=c(1,1,4,1))
persp(x,y,f,theta = 0, phi = -40, col = "lightblue",xlab = "X", ylab = "Y", zlab ="Z",main="rho=0.5",cex.main=0.8)
```

##  Grafica de Contornos de Superficies de Normaales Bivariadas                            
```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
x<-seq(0,10,len=60)
y<-seq(0,10,len=60)

media <- c(5, 5)
varianza <- matrix(c(1.3, 1, 1, 1.3), ncol=2)

fun <- function(x, y) dmvnorm(c(x, y), mean=media, sigma=varianza)
fun <- Vectorize(fun)

z<-outer(x,y,fun)

par(mfrow=c(1,2))
persp(x, y, z, theta=-10, phi=20, expand=0.8, axes=FALSE,box=F)

contour(x,y,z, nlevels=3,levels=c(0.01,0.05,0.1),labels=c(0.01,0.05,0.1),lwd=1.5,xlab=expression(x[1]),ylab=expression(x[2]),main="Contornos de verosimilitud del 90%,95% y 99%",cex.main=0.85)
```

## Prueba de Normalidad Univariada del Coeficiente de Correlación, Ejemplo de notas de Clase

Prueba de Normalidad Univariada mediante la Prueba del Coeficiente de Correlación.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
ejemplo<-c(-1,-0.10,0.16,0.41,0.62,0.80,1.26,1.54,1.71,2.30)
```

En la tabla \ref{ejemplo1-notas}, están los datos de un ejemplo visto en clase.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(kableExtra)
matrix(ejemplo, nrow=1, ncol = 10, byrow=TRUE) %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{ejemplo1-notas}Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

library(ggplot2) 
ejemplo1<-data.frame(ejemplo)

p<-ggplot(ejemplo1, aes(sample = ejemplo1[,1]) ) 
p + geom_qq() + geom_qq_line()+
         labs(title="Normal Probaility Plot o QQ-plot",
           x = "Valores Teóricos (Estadísticos de Orden)", 
              y = "Valores Muestrales (Quantiles)")+
  theme_bw() +
    theme(axis.text.x = element_text(colour = "grey20", size = 10, angle = 0,
                                     hjust = 0.5, vjust = 0.5),
          axis.text.y = element_text(colour = "grey20", size = 10),
          text = element_text(size = 12))+
  theme(
    panel.background = element_rect(fill = "lightblue"),
    panel.grid.minor = element_line(linetype = "dotted")
  )
ggsave("figurasR/npp.png")
#qqnorm(ejemplo); qqline(ejemplo)
```

**Resultados de la prueba de normalidad univariada vía la PH del coeficiente de Correlación**:
```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(ppcc)
ppccTest(ejemplo, "qnorm")
#ppccTest(ejemplo)
```

## Ejemplo de Notas de Clases (Manual)

Prueba del coeficiente de correlación realizada de manera manual.

\begin{center}
\begin{tabular}{cccc}\hline
Tamaño de & 
\multicolumn{3}{c}{Nivel de Significancia $\alpha$ }\\\cline{2-4}
muestra $n$ & 0.01 & 0.05 & 0.10 \\\hline
5&0.8299&0.8788&0.9032\\
10&0.8801&0.9198&0.9351\\
15&0.9126&0.9389&0.9503\\
20&0.9269&0.9508&0.9604\\
25&0.9410&0.9591&0.9665\\
30&0.9479&0.9652&0.9715\\
35&0.9538&0.9682&0.9740\\
40&0.9599&0.9726&0.9771\\
45&0.9632&0.9749&0.9792\\
50&0.9671&0.9768&0.9809\\
55&0.9695&0.9787&0.9822\\
60&0.9720&0.9801&0.9836\\
75&0.9771&0.9838&0.9866\\
100&0.9822&0.9873&0.9895\\
150&0.9879&0.9913&0.9928\\
200&0.9905&0.9931&0.9942\\
300&0.9935&0.9953&0.9960\\\hline
\end{tabular}
\end{center}

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
n<-length(ejemplo)
pj<-round((1:n-0.5)/n,4)
qj<-round(qnorm(pj),4)
cor<-cor(qj,sort(ejemplo))
```
El Coeficiente de Correlación es $r$=:`r cor`
\newline

El Valor tabulado en la tabla es: $T_{tabla}=R(n,\alpha)=R(10,0.05)=0.9351$ luego, Como $r>T$-tabulado, luego no se rechaza $H_0:$ Los datos son Normales Univariados.

## TRANSFORMACIONES DE POTENCIA INDIVIDUALES (Box-Cox)

Ahora se realizan transformaciones de Box-Cox para acercar los datos a la normalidad univariada.

Primero se tiene la prueba de Shapiro Wilk para Normalidad Univariada para los datos crudos.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos<-read.table("datos/T4-1.dat",dec =".") 
datos2<-cbind(datos[1:10,],datos[11:20,],datos[21:30,],datos[31:40,],datos[c(41,42),])
```

En la tabla \ref{ejemplo2-notas}, están los datos de un segundo ejemplo visto en clase.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos2 %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{ejemplo2-notas}Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)

library(car)
x<-data.frame(datos)
#dev.new(width=10, height=10)
p<-ggplot(x, aes(sample = x[,1]) ) 
p + geom_qq() + geom_qq_line()+
         labs(title="NPP de Datos Crudos",
           x = "Valores Teóricos", 
              y = "Quantiles Muestrales")+
  theme_bw() +
    theme(axis.text.x = element_text(colour = "grey20", size = 10, angle = 0,
                                     hjust = 0.5, vjust = 0.5),
          axis.text.y = element_text(colour = "grey20", size = 10),
          text = element_text(size = 12))+
  theme(
    panel.background = element_rect(fill = "lightblue"),
    panel.grid.minor = element_line(linetype = "dotted")
  )
QQnorm(x[,1])
#shapiro.test(x[,1])
```

**Ahora se tiene la prueba de Shapiro Wilk para Normalidad Univariada para los datos transformados**.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
## para datos transformados
landa=powerTransform(x[,1])
landaf<-landa$lambda
xt<-data.frame((x[,1]^landaf-1)/landaf)
p<-ggplot(xt, aes(sample = xt[,1]) ) 
p + geom_qq() + geom_qq_line() + 
         labs(title="NPP de Datos Transformados",
           x = "Valores Teóricos", 
              y = "Valores Muestrales")+
  theme_bw() +
    theme(axis.text.x = element_text(colour = "grey20", size = 10, angle = 0,
                                     hjust = 0.5, vjust = 0.5),
          axis.text.y = element_text(colour = "grey20", size = 10),
          text = element_text(size = 12))+
  theme(
    panel.background = element_rect(fill = "lightblue"),
    panel.grid.minor = element_line(linetype = "dotted")
  )
QQnorm_transf(xt[,1])
```

## Cálclulo del coeficiente de asimetría de Fisher y el coeficiente de Kurtosis para un  conjunto de datos-univariado

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
### Generacion de datos normales
n<-100;z=rnorm(n);media=mean(z);mediana<-median(z)
s2=var(z)*(n-1)/n ; s=sqrt(s2)

datos<-cbind(z[1:20],z[21:40],z[41:60],z[61:80],z[81:100])
library(kableExtra)
datos %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{datos-uni-generados}Datos Normales  Univariados Generados",row.names = TRUE) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,
  full_width = FALSE)

# obtención del coeficiente de asimetría y Kurtosis muestral
a_normal<-asimetria(z)
k_normal<-kurtosis(z)
```
**El coeficiente de Asimetría para el conjunto de datos Univariado Generados es**: $A =$ `r a_normal`

**El coeficiente de Kurtosis para el conjunto de datos Univariado Generados es**: $K =$ `r k_normal`

## Test Para Normalidad Univariada basado en el Coeficiente de Asimetría.

Ahora se tiene una PH de Normalidad Univariada basada en el Coeficiente de asimetría, cuyo estadístico de prueba es:
$$
Z=\sqrt{n/6}*A \sim N(0,1), \ \ \text{donde:} \ \ A-\text{Coeficiente de Asimetría}.
$$

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
estadistico_normal=sqrt(n/6)*a_normal ## Este estadístico se distribuye N(0,1)
```
**El estadístico de prueba es**: $Z =$  `r round(estadistico_normal,4)`

**El Valor-p de la prueba de Asimetria Normal Univariada es:** $p_{-valor} =$ `r round(2*( 1 - pnorm( abs(estadistico_normal) ) ),4)`

## Test Para Normalidad Univariada basado en el Coeficiente de Kurtosis.

Ahora se tiene una PH de Normalidad Univariada basada en el Coeficiente de Kurtosis, cuyo estadístico de prueba es:
$$
Z=\sqrt{n/24}*(K-3) \sim N(0,1), \ \ \text{donde:} \ \ K-\text{Coeficiente de Kurtosis}.
$$

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
estad_normal=sqrt(n/24)*(k_normal-3) ## Este estadístico se distribuye N(0,1)
```

**El estadístico de prueba es**: $Z =$  `r round(estad_normal,4)`

**El Valor-p de la prueba de Kurtosis Normal Univariada es:** $p_{-valor} =$ `r round(2*( 1 - pnorm( abs(estad_normal) ) ),4)`

## Pruebas de Normalidad Multivariada

Se utiliza la función `mvn` del paquete *MVN* para realizar pruebas de Normalidad Multivariada y Univariada con distintas opciones de visualización.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(MVN)
datos<-read.table("datos/T1-5.dat",dec =".")
```

En la tabla \ref{datos}, se encuentra el Conjunto de conjunto completos.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(kableExtra)
datos %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{datos}Conjunto de Datos",row.names = TRUE) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,
  full_width = FALSE)
```

En la tabla \ref{salidas-ph-NM}, se tienen las salidas básicas de la función `mvn`. La prueba multivariada usada es la de Mardia. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
mvn(datos[,c(2,5)],mvnTest=c("mardia"),univariateTest=c("SW")) %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{salidas-ph-NM}Salidas Básicas de PH-NM") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

En la tabla \ref{ph-nm}, se tienen las salidas de la función `mvn` para la prueba normal  multivariada usada, en este caso la prueba de Mardia. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1<-mvn(datos[,c(2,5)],mvnTest=c("mardia"),univariateTest=c("SW"))
result1$multivariateNormality %>%
kable(booktabs = TRUE,format = "latex",caption="\\label{ph-nm}Prueba de Normalidad Multivariada",align = c('c', 'r', 'r', 'c'), col.names = c("Prueba","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,NA,NA,NA),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

En la tabla \ref{ph-nu}, se tienen las salidas de la función `mvn` para las pruebas normal  univariada usada, en este caso la prueba de Shapiro-Wilk. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$univariateNormality %>% 
kable(booktabs = TRUE,format = "latex",caption="\\label{ph-nu}Prueba de Normalidad Univariada", align = c('c', 'c', 'c', 'c', 'c'),col.names = c("Prueba","Variables","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,NA,3,3,NA),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

En la tabla \ref{descriptivos0}, se tiene un resumen descriptivo de las variables del conjunto de datos p-variado usado, en este caso el conjunto de datos consta de dos variables.  Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$Descriptive %>% 
kable(booktabs = TRUE,format = "latex",caption="\\label{descriptivos0}Resumen Descriptivo", align = c("c", "c", "r", "r", "r", "r", "r", "r", "r", "r", "r"),  col.names = c("n", "Media", "DesvEst", "Mediana", "Min", "Máx", "Per.25", "Per.75", "Asimetría", "Kurtosis"),   digits=c(0,3,3,3,3,3,3,3,3,3,3),  format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

## Coeficientes de Asimetría y Kurtosis Multivariado-Distancia de Mahalanobis

Los coeficientes de Asimetría y Kurtosis **UNIVARIADOS** son respectivamente: `r asimetria(datos[,2])` y `r kurtosis(datos[,2])-3` para la variable $V_2$ y `r asimetria(datos[,5])` y `r kurtosis(datos[,5])-3` para la variable $V_5$. 

En la tabla \ref{mahalanobis}, se tienen las distnacias de Mahalanobis (al cuadrado) de cada Observación al vector de medias de los datos. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
x<-as.matrix(datos[,c(2,5)])
n<-nrow(x)
media<-apply(x,2,mean)
var<-var(x)
s=var*(n-1)/n
# Uso de la función: mahalanobis
distancias2<-mahalanobis(x,media,s)
distancias2<-cbind(distancias2[1:10],distancias2[11:20],distancias2[21:30],distancias2[31:40],distancias2[41:42])
round(distancias2,4) %>% 
kable(booktabs = TRUE,format = "latex",caption="\\label{mahalanobis}Distancias de Mahalanobis a la media") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8, full_width = FALSE)
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
#--- Diagonalización de s
auto=eigen(s)
v=auto$vectors
lambda=auto$values
si12=v%*%diag(1/sqrt(lambda))%*%t(v)
#--- Estandarización multivariada
xs=(x-rep(1,n)%*%t(media))%*%si12
#--- Similaridades
r=xs%*%t(xs)
asimetria_multv<-(1/n^2)*sum(r^3)
```
luego, en este caso el Coeficiente de Asimetría Multivariado es $A_m =$ `r asimetria_multv`. 

**El Coeficiente de Asimetría Multivariado esta dado por:** 
$$
A_m=\frac{1}{n^2}\sum_{i=1}^n\sum_{j=1}^n r_{ij}^3
$$
$$
\text{donde:}\ \ \ \ r_{ij}=(\underline{\mathbf{x}}_i-\overline{\underline{\mathbf{x}} })^T\mathbf{S}^{-1}(\underline{\mathbf{x}}_j-\overline{\underline{\mathbf{x}} }).
$$
Para $i=j$ se tienen las distancias de Mahalanobis de cada observación al vector de medias,  es decir,
$$
d_M^2\ \bigl(\ \underline{\mathbf{x}}_i\ , \ \overline{\underline{\mathbf{x}} }\ \bigr)=r_{ii}=
(\underline{\mathbf{x}}_i-\overline{\underline{\mathbf{x}} })^T\mathbf{S}^{-1}(\underline{\mathbf{x}}_i-\overline{\underline{\mathbf{x}} })
$$
luego, en este caso el Coeficiente de Asimetría Multivariado es $A_m =$ `r asimetria_multv`. 

**El Coeficiente de Kurtosis Multivariado esta dado por:** 
$$
K_m=\frac{1}{n}\sum_{i=1}^n r_{ii}^2=\frac{1}{n}\sum_{i=1}^n d_M^4\ \bigl(\ \underline{\mathbf{x}}_i\ , \ \overline{\underline{\mathbf{x}} }\ \bigr)
$$ 
```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
kurtosis_multv<-(1/n)*sum(distancias2[1:42]^2)
km=(1/n)*sum(diag(r)^2)
```
luego, en este caso el Coeficiente de Kurtosis Multivariado es $K_m =$ `r kurtosis_multv`=`r  km` 

## Mas Ejemplos de NM1

En la tabla \ref{ph-nm-royston}, están las Salidas básicas de la función `mvn` usando la  *prueba multivariada de Royston*. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
mvn(datos[,c(2,5)],mvnTest=c("royston"),univariateTest=c("SW")) %>% 
kable(booktabs = TRUE,format = "latex",caption="\\label{ph-nm-royston}Salidas Básicas PH NM- Royston") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result2<-mvn(datos[,c(2,5)],mvnTest=c("royston"),univariateTest=c("SW"))
result2$multivariateNormality %>% 
kable(booktabs = TRUE,format = "latex",caption="Prueba de Normalidad Multivariada",align = c('c', 'r', 'r', 'c'), col.names = c("Prueba","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,4,4,NA),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result2$univariateNormality %>%
kable(booktabs = TRUE,format = "latex",caption="Prueba de Normalidad Univariada", align = c('c', 'c', 'c', 'c', 'c'),
      col.names = c("Prueba","Variables","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,NA,4,4,NA),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result2$Descriptive %>%
kable(booktabs = TRUE,format = "latex",caption="Resumen Descriptivo", align = c("c", "c", "r", "r", "r", "r", "r", "r", "r", "r", "r"),  col.names = c("n", "Media", "DesvEst", "Mediana", "Min", "Máx", "Per.25", "Per.75", "Asimetría", "Kurtosis"),   digits=c(NA,3,3,3,3,3,3,3,3,3,3),  format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)
```

## Mas Ejemplos de NM2

Salidas básicas de la función _mvn_. La prueba multivariada usada es la de Mardia. Favor ver la ayuda del R para esta función y explorar  los distintos argumentos de la misma.

En la tabla \ref{datos-gen}, se encuentra el ancabezado del conjunto de datos Normal Multivariado generados a partir del R.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(clusterGeneration)
sigma<-genPositiveDefMat("eigen",dim=5)$Sigma  
mu=c(0,0,0,0,0)
datos_gen<-as.data.frame(mvrnorm(n=100, mu,sigma))
datos_gen %>% 
  kable(booktabs = TRUE,format = "latex",caption="\\label{datos-gen}Conjunto de Datos NM Generados", row.names = TRUE,longtable=TRUE,digits=5, col.names=c("X1","X2","X3","X4","X5")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position","repeat_header"),
  position = "center", font_size=8, full_width = FALSE,
  repeat_header_text = "continuación",
  repeat_header_continued="continúa en la siguiente página")
```

En la tabla \ref{nor-multiv}, se encuentran los resultados de la prueba de normalidad multivariada realizada según la prueba seleccionada de las disponibles en el argumento _mvnTest_ de la función _mvn_.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1<-mvn(datos_gen,mvnTest=c("mardia"),univariateTest=c("SW"))
result1$multivariateNormality %>%
kable(booktabs = TRUE,format = "latex",caption="\\label{nor-multiv}Prueba de Normalidad Multivariada",align = c('c', 'r', 'r', 'c'),col.names = c("Prueba","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,5,5,NA)) %>% 
kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

En la tabla \ref{nor-univ}, se encuentran los resultados de las pruebas de normalidad univariadas para cada una de las variables del conjunto de datos p-variados.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$univariateNormality %>%
kable(booktabs = TRUE,format = "latex", caption="\\label{nor-univ}Prueba de Normalidad Univariada", align = c('c', 'c', 'c', 'c', 'c'), col.names = c("Prueba","Variables","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,NA,3,3,0),format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", full_width = FALSE)
```

En la tabla \ref{descriptivos2} aparece un resumen descriptivo de las variables del conjunto de datos p-variado. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1$Descriptive %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{descriptivos2}Resumen Descriptivo", align = c("c", "c", "r", "r", "r", "r", "r", "r", "r", "r", "r"),  col.names = c("n", "Media", "DesvEst", "Mediana", "Min", "Máx", "Per.25", "Per.75", "Asimetría", "Kurtosis"),   digits=c(0,3,3,3,3,3,3,3,3,3,3),  format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","scale_down","HOLD_position"),
  position = "center", full_width = FALSE)
```

## Gráficos QQ-Plot

Resultados con Gráfico QQ-Plot para la PH de Normalidad Multivariada utilizando la función `mvn`.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul2<-mvn(datos_gen,mvnTest=c("mardia"),univariateTest=c("SW"),multivariatePlot="qq")
```

## Pruena de NM de Shapiro-Wilk

Prueba de Shapiro_Multivariada para normalidad con la función `mshapiro.test` del paquete:  *mvnormtest*.

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
library(RVAideMemoire)
library(mvnormtest)
mshapiro.test(t(datos_gen))
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
result1<-mvn(datos_gen,mvnTest=c("royston"),univariateTest=c("SW"))
result1$multivariateNormality %>%
kable(booktabs = TRUE,format = "latex",caption="\\label{nor-multiv}Prueba de Normalidad Multivariada de Royston",align = c('c', 'r', 'r', 'c'),col.names = c("Prueba","Valor Estadística","Valor-p","Resultado"),row.names = TRUE,digits =c(NA,5,5,NA)) %>% 
kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

## Prueba de Norm. multivariada basada en Asimetría 

A continuación se tienen los resultados de la PH para NM basada en Asimetría, utilizando la función `mvnorm.skew.test` del paquete *ICS*. Favor exlorar este paquete y sus funciones disponibles.

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
library(ICS)
mvnorm.skew.test(datos_gen)

mvnorm.skew.test(datos[,c(2,5,6)])
```

## Gráfico QQ-Plot (chi-Cuadrado)

Gráfico qq-plot para Normalidad Multivariada con la función `mqqnorm`.

```{r echo=FALSE, message=FALSE, comment=FALSE, results="asis"}
mqqnorm(datos_gen,main="Gráfico QQ-Plot para Normalidad Multivariada")
```

## Mas ejemplos de Prueba de NM3

Resultados con Gráfico Box-Plot para la PH de Normalidad Multivariada utilizando la función `mvn`.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul3<-mvn(datos_gen,mvnTest=c("mardia"),univariateTest=c("SW"),univariatePlot="box",desc=FALSE)
resul3 %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{salidas-sin-desc}Salidas sin Resumen Descriptivo",format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", full_width = FALSE)
```

En la tabla \ref{salidas-con-box-cox}, se tienen los resultados de PH con la función `mvn` junto con Observaciones atípicas y transformaciones de Box-Cox.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul4<-mvn(datos[,c(2,5,6)],mvnTest=c("mardia"),univariateTest=c("SW"),
            multivariateOutlierMethod="quan",bc=TRUE,bcType="optimal",
            showOutliers=TRUE,desc=TRUE)
resul4 %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{salidas-con-box-cox}Salidas Obs. Atípicas y Tranf. de Box-Cox",format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

En la tabla \ref{obs-atipicas}, se muestran las observaciones atípicas en los datos.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul5<-mvn(datos[,c(2,5,6)],mvnTest=c("mardia"),univariateTest=c("SW"),
multivariateOutlierMethod="quan",bc=TRUE,bcType="optimal",showOutliers=TRUE,showNewData=TRUE)

resul5$multivariateOutliers %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{obs-atipicas}Observaciones Atípicas",format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

En la tabla \ref{box-cox}, se muestran los valores de Lambda para las transformaciones de Box-Cox.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul5<-mvn(datos[,c(2,5,6)],mvnTest=c("mardia"),univariateTest=c("SW"),
multivariateOutlierMethod="quan",bc=TRUE,bcType="optimal",showOutliers=TRUE,showNewData=TRUE)

resul5$BoxCoxPowerTransformation %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{box-cox}Valores de lambda para Box-Cox",format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

En la tabla \ref{datos-transf}, se muestran los nuevos datos transfromados con Box-Cox.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
resul5<-mvn(datos[,c(2,5,6)],mvnTest=c("mardia"),univariateTest=c("SW"),
multivariateOutlierMethod="quan",bc=TRUE,bcType="optimal",showOutliers=TRUE,showNewData=TRUE)

resul5$newData %>% 
kable(booktabs = TRUE,format = "latex", caption="\\label{datos-transf}Datos transformados con Box-Cox",row.names=TRUE,format.args = list( decimal.mark = ".")) %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center", font_size=8,full_width = FALSE)
```

## Función R que representa datos bivariados, junto con elipses de confianza

Con esta función se realzia un gráfico de dispersión de dos variables junto con dos elipses de confianza del $(1-\alpha_1)100\%$ y $(1-\alpha_2)100\%$. El centro de la elipse está representado por un punto de color azul.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
representa2=function(x,alfa1,alfa2,texto){ # Los datos se encuentran en la matriz x
p=ncol(x)     ##  Número de variables=2
n=nrow(x)     ##  Número de individuos
#####--- Cálculo del vector de medias y matriz de covarianzas
med=apply(x,2,mean)
sc=cov(x)           ## S
s=sc*(n-1)/n        ## Sn
#####--- Diagonalización de s
auto=eigen(s)

v=auto$vectors      ## Vectores propios
lambda=auto$values  ## Valores  propios

#####--- Gráfico de Dispersión
library(latex2exp)
plot(x[,1],x[,2],xlab=texto,ylab="",pch=20, xlim=c(min(x[,1])-1,max(x[,1])+1), ylim=c(min(x[,2])-1,max(x[,2])+1), 
     main = TeX('Con\ \ $\\underline{\\mu}$\ y $\\mathbf{\\Sigma}$ \ \ dados, \ \ $(1-\\alpha_1)$, $(1-\\alpha_2)100\\%$ '))
points(med[1],med[2],pch=19,col="blue")  ## El centroide, (x-barra,y-barra)
abline(h=med[2],lty=2)
abline(v=med[1],lty=2)

####### Gráfico de la Elipse
teta=seq(0,2*pi,length=101)   ## Vector con los ángulos
#####--- Truco para repetir el vector de medias k veces, en 101 filas
medr=matrix(rep(med,101),byrow=TRUE,nrow=101)

c1<-qchisq(alfa1,2)
c2<-qchisq(alfa2,2)

elipse01=medr+sqrt(c1)*t(sqrt(lambda[1])*v[,1]%*%t(cos(teta))+sqrt(lambda[2])*v[,2]%*%t(sin(teta)))  ## contorno eliptico del alfa1%

elipse02=medr+sqrt(c2)*t(sqrt(lambda[1])*v[,1]%*%t(cos(teta))+sqrt(lambda[2])*v[,2]%*%t(sin(teta)))  ## contorno eliptico del alfa2%
lines(elipse01,col="blue")
lines(elipse02,col="red")
}
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(MASS)
library(mvtnorm)
library(MVN)

par(mfrow=c(2,2))
mu=c(2,2)

mu=c(2,2)
sigma<-matrix(c(5,4,4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)

representa2(datos2,0.9,0.95,"(a) Normal Bivariada")   

mu=c(0,0)
sigma<-matrix(c(3,0,0,3),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.5,0.95,"(a) Normal Bivariada")   

mu=c(2,0)
sigma<-matrix(c(5,-4,-4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.5,0.95,"(a) Normal Bivariada")   

mu=c(0,2)
sigma<-matrix(c(5,-4,-4,10),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa2(datos2,0.5,0.95,"(a) Normal Bivariada")  
```

Se utiliza la función `genPositiveDefMat` del paquete *clusterGeneration* para generar Matrices Simétricas Definida-Positiva que se usan como Matrices de Var-Cov $\pmb{\Sigma}$  de los datos Normales Multivariados generados posteriormente.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(clusterGeneration)
sigma<-genPositiveDefMat("eigen",dim=2)$Sigma  
mu=c(0,0)
datos2<-round(mvrnorm(n=100, mu,sigma),4)

cat("\n La matriz de Var-Cov Utilizada es:\ \ \n") 

library(kableExtra)
sigma %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matrix Var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa2(datos2,0.5, 0.90, "(a) Normal Bivariada")  
```

Ahora para un conjunto de **datos bi-variados dado**, se utiliza la función anterior para representar los datos gráficamente junto a elipses de confianza específicas. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos<-read.table("datos/T1-5.dat",dec =".")

datos2<-datos[,c(5,6)]

head(datos2,5) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Encabezado de Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)


cat("\n El Vector de medias y La matriz de Var-Cov Utilizadas son:\ \ \n") 

apply(datos2,2,mean) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Vector de Medias") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

var(datos2) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matriz de var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa2(datos2,0.5, 0.90, "(a) Datos Bivariados")  
```

## Función R que representa datos bivariados, junto con el vector de medias

Con esta función se realzia un gráfico de dispersión de dos variables junto con una elipse de confianza del $(1-\alpha)100\%$. El centro de la elipse está representado por un punto de color azul.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
representa1=function(x,alfa1,texto){
p=ncol(x)     
n=nrow(x)     
med=apply(x,2,mean)
sc=cov(x)           
s=sc*(n-1)/n        
auto=eigen(s)
v=auto$vectors      
lambda=auto$values  
library(latex2exp)
plot(x[,1],x[,2],xlab=texto,ylab="",pch=20, xlim=c(min(x[,1])-1,max(x[,1])+1), ylim=c(min(x[,2])-1,max(x[,2])+1), 
     main = TeX('Con\ \ $\\underline{\\mu}$\ y $\\mathbf{\\Sigma}$ \ \ dados, \ \ $(1-\\alpha)100\\%$ '))
points(med[1],med[2],pch=19,col="blue")        
abline(h=med[2],lty=2)
abline(v=med[1],lty=2)
teta=seq(0,2*pi,length=101)                    
medr=matrix(rep(med,101),byrow=TRUE,nrow=101)
c1<-qchisq(alfa1,2)
elipse01=medr+sqrt(c1)*t(sqrt(lambda[1])*v[,1]%*%t(cos(teta))+sqrt(lambda[2])*v[,2]%*%t(sin(teta))) 
#lines(elipse01,col="blue",type="n")
lines(elipse01,col="blue",type="l")
}
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
par(mfrow=c(2,2))
mu=c(2,2)

mu=c(2,2)
sigma<-matrix(c(5,4,4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.95,"(a) Normales")   

mu=c(0,0)
sigma<-matrix(c(3,0,0,3),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.5,"(a) Normales")   

mu=c(2,0)
sigma<-matrix(c(5,-4,-4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.85,"(a) Normales")   

mu=c(0,2)
sigma<-matrix(c(5,-4,-4,10),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1(datos2,0.9,"(a) Normales")  
```
Con esta función se realzia una elipse de confianza del $(1-\alpha)100\%$. El centro de la elipse está representado por un punto de color azul.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
representa1B=function(x,alfa1,texto){
p=ncol(x)     
n=nrow(x)     
med=apply(x,2,mean)
sc=cov(x)           
s=sc*(n-1)/n        
auto=eigen(s)
v=auto$vectors      
lambda=auto$values  
library(latex2exp)
plot(x[,1],x[,2], type="n", xlab=texto,ylab="",pch=20, xlim=c(min(x[,1])-1,max(x[,1])+1), ylim=c(min(x[,2])-1,max(x[,2])+1), 
     main = TeX('Con\ \ $\\underline{\\mu}$\ y $\\mathbf{\\Sigma}$ \ \ dados, \ \ $(1-\\alpha)100\\%$ '))
points(med[1],med[2],pch=19,col="blue")        
abline(h=med[2],lty=2)
abline(v=med[1],lty=2)
teta=seq(0,2*pi,length=101)                    
medr=matrix(rep(med,101),byrow=TRUE,nrow=101)
c1<-qchisq(alfa1,2)
elipse01=medr+sqrt(c1)*t(sqrt(lambda[1])*v[,1]%*%t(cos(teta))+sqrt(lambda[2])*v[,2]%*%t(sin(teta))) 
#lines(elipse01,col="blue",type="n")
lines(elipse01,col="blue",type="l")
}
```

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
par(mfrow=c(2,2))
mu=c(2,2)

mu=c(2,2)
sigma<-matrix(c(5,4,4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1B(datos2,0.95,"(a) Normales")   

mu=c(0,0)
sigma<-matrix(c(3,0,0,3),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1B(datos2,0.5,"(a) Normales")   

mu=c(2,0)
sigma<-matrix(c(5,-4,-4,5),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1B(datos2,0.85,"(a) Normales")   

mu=c(0,2)
sigma<-matrix(c(5,-4,-4,10),ncol=2)
datos2<-round(mvrnorm(n=100, mu,sigma),3)
representa1B(datos2,0.9,"(a) Normales")  
```

Se utiliza la función `genPositiveDefMat` del paquete *clusterGeneration* para generar Matrices Simétricas Definida-Positiva que se usan como Matrices de Var-Cov $\pmb{\Sigma}$  de los datos Normales Multivariados generados posteriormente.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
library(clusterGeneration)
sigma<-genPositiveDefMat("eigen",dim=2)$Sigma  
mu=c(0,0)
datos2<-round(mvrnorm(n=100, mu,sigma),4)

cat("\n La matriz de Var-Cov Utilizada es:\ \ \n") 

sigma %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matriz de var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa1(datos2,0.90, "(a) Normal Bivariada")  
```

Con esta función se realzia un gráfico de dispersión de dos variables junto con una elipse de confianza del $(1-\alpha)100\%$. El centro de la elipse está representado por un punto de color azul.

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos<-read.table("datos/T1-5.dat",dec =".")

datos2<-datos[,c(5,6)]

head(datos2,5) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Encabezado de Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

cat("\n El Vector de medias y La matriz de Var-Cov Utilizadas son:\ \ \n") 

apply(datos2,2,mean) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Vector de Medias") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

var(datos2) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matriz de var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa1(datos2, 0.90, "(a) Datos Bivariados")  
```

Ahora para un conjunto de **datos bi-variados dado**, se utiliza la función anterior para representar una elipse de confianza específica. 

```{r, echo=FALSE,results="asis",comment=FALSE,message=FALSE}
datos<-read.table("datos/T1-5.dat",dec =".")

datos2<-datos[,c(5,6)]

head(datos2,5) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Encabezado de Datos") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

cat("\n El Vector de medias y La matriz de Var-Cov Utilizadas son:\ \ \n") 

apply(datos2,2,mean) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Vector de Medias") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

var(datos2) %>% 
  kable(booktabs = TRUE,format = "latex",caption="Matriz de var-Cov") %>%
  kable_styling(latex_options = c("striped", "condensed","HOLD_position"),
  position = "center",full_width = FALSE)

representa1B(datos2, 0.90, "(a) Datos Bivariados")  
```


